/**
 * 📌 즉시 실행 함수 
 * 1. 함수 정의와 동시에 즉시 호출되는 함수로 단 한번만 실행되며 다시 호출 할 수 없음
 * 2. 정의한 함수를 ()-그룹연산자 로 감싼 후 ()을 붙여 실행 
 * 3. 익명 함수를 사용하는게 일반적임 
 * 4. 기명 함수도 가능하긴 하나 해당 이름으로 다시 재호출은 불가
 */
 
/**
 * 📌 중첩 함수 
 * 1. 함수 내부에서 정의된 함수를 중첩함수 또는 내부함수라고 함 
 * 2. 중첩함수를 포함하는 함수는 외부함수라고 함 
 * 3. 일반적으로 중첩함수는 자신을 포함하는 외부함수를 돕는 헬퍼함수의 역할을 함 
 * 4. 외부함수는 내부함수 변수를 사용할 수 없음
 *    단, 내부함수는 외부함수의 변수를 사용할 수 있음 
 */

(function() {
  console.log('익명함수 즉시실행! 함수 정의와 동시에 호출');
});

(function(){
  let name;
});


function fnOuter(a){
  console.log('외부함수',a,b);
  
   fnInner(a+1);
    
  function fnInner(b){
    console.log('내부함수', a, b);
  } 
}; // 내부함수는 외부에서 접근 불가 : 함수 스코프의 캡술화 
// 내부함수는 외부함수 안에서만 호출 가능
// 외부함수의 변수는 내부함수에서 자유롭게 접근 가능
// 이를 통해 데이터 보호와 코드 구조화 달성

/**
 * 📌 콜백 함수 
 * 1. 인자로 다른 함수에 전달되서 실행되는 함수 
 * 2. 콜백함수를 전달받은 함수는 고차함수 라고 함 
 * 3. 즉, 콜백함수는 고차함수에 전달되어 헬퍼함수의 역할을 함
 * 
 * a 함수를 전달받은 b 함수는 본문에서 전달받은 a 함수를 다시 호출해야되므로 callback이라 함 
 * a 함수 == 콜백함수
 * b 함수 == 고차함수 
 */

// 예시 1) 경우에 따라 특정 값을 중가 또는  감소
function increase(value){
  return value + 1;
}; 

function decrease(value){
  return value -1;
};


function apply(value, funk){
   return funk(value);
}; //value = 값, funk = 실행 함수

console.log(apply(5,increase));
// 결론 : 콜백함수 = 함수를 매개변수로 전달해서 동작 제어

console.log(apply(5, (a)=>a*2));


//예시2) 로그인처리시 아이디/비번/이메일 중 두개를 체크해야한다 가정
// 각 요소를 체크하는 함수 정의
const idCheck =() => console.log('아이디 체크 로직 실행');
const pwdCheck =() => console.log('비밀번호 체크 로직 실행');
const emailCheck =() => console.log('이메일 체크 로직 실행');

// 로그인 처리용 함수(매번 경우에 따라서 체크해야될 두개의 함수 콜백함수로 전달)
const login = (check1, check2) => {
  console.log('로그인 공통 로직 먼저 실행');
  // 검증을 위한 두개의 함수 실행
  check1();
  check2();
};

login(idCheck,pwdCheck);

//결론 : 코드 선언시 , 함수 내에서 해야함 >> 충돌, 값변경 최소화 가능하기 때문
//       콜백함수 = 함수를 매게 변수 처럼 쓰는 것. 콜백함수를 이용해 내부 작동을 유연하게 한다. 
// 유연성 - 상황에 맞게 동작 변경 / 재사용성 - 공통로직은 한번만 작성. / 확장성- 새로운 체크함수 추가에도 기존 코드 수정없음
